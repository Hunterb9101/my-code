#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  HTServo)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     gyro,           sensorI2CHiTechnicGyro)
#pragma config(Sensor, S4,     irBeacon,       sensorHiTechnicIRSeeker1200)
#pragma config(Motor,  mtr_S1_C1_1,     DriveLeft,     tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     DriveRight,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     ArmRot,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     ArmLift,        tmotorTetrix, openLoop, reversed)
#pragma config(Servo,  srvo_S1_C3_1,    GoalHook,             tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    TrapDoor,        tServoStandard)
#pragma config(Servo,  srvo_S1_C3_3,    SweepRotLeft,         tServoStandard)
#pragma config(Servo,  srvo_S1_C3_4,    Sweeper,              tServoContinuousRotation) // Need to Check
#pragma config(Servo,  srvo_S1_C3_5,    ScoopRotRight,        tServoStandard)
#pragma config(Servo,  srvo_S1_C3_6,    ScoopRotLeft,         tServoStandard)
#pragma config(Servo,  srvo_S1_C4_1,    SweepRotRight,             tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    servo8,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_3,    servo9,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_4,    servo10,              tServoNone)
#pragma config(Servo,  srvo_S1_C4_5,    servo11,              tServoNone)
#pragma config(Servo,  srvo_S1_C4_6,    servo12,              tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

////////////////////////////////////////////
//                                        //
//                                        //
//  Autonomous Program 7208               //
//  2014-15                               //
//  Competiton use                        //
//                                        //
//                                        //
////////////////////////////////////////////

////////////////////////////
// Includes               //
////////////////////////////

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth or wifi messages from the FCS and Joysticks

#include "Drivers/3rdParty/drivers/hitechnic-gyro.h"  //Include file for the gyro sensor utilities
//#include "SensorDrivers/drivers/hitechnic-gyro.h" // If the earlier one doesn't work

////////////////////////////
// Definitions            //
////////////////////////////

typedef enum {FORWARD,BACKWARD}Movedir; // What direction are you traveling in???
typedef enum {LEFT,RIGHT}Turndir;       // What direction are you going to turn???
typedef enum {INCHES,FEET}IncrementSize;

////////////////////////////
// Strategy Variables     //
////////////////////////////

string gStartPos[] = {"Parking Zone (PZ)","Ramp"}; // Positon of Robot
int gStartPosIdx = 0;
int gMaxStartPos = 1;

string gStrategy[] = {"Offense","Defense","Hybrid"} ; // Biased towards Offense or Defense
int gStrategyIdx = 0;
int gMaxStrategy = 2;

string gScore[] = {"Center Goal","Small Goal","None"};
int gScoreIdx = 0;
int gMaxScoreO = 1;  // Max Score Ways for Offense Ramp
int gMaxScoreH = 2;  // Max Score Ways for Hybrid Ramp

bool gGoal2PZPZ = false; // Goal to Parking Zone from start position Parking Zone

string gBlock[] = {"Center Goal","Kickstand"};
int gBlockIdx = 0;
int gMaxBlock = 1;

bool gGoal2PZRO  = false; // Goal to Parking Zone from start position Ramp

bool gSmallGoal = false;

bool gBlockCenterGoal = false;

string gScoreHPZ[] = {"None","Center Goal","Kickstand","Both"};
int gScoreHPZidx = 0;
int gMaxScoreHPZ = 3;

string gEndPosHPZ[] = {"None","Center Goal","Kickstand","Goal to PZ"};
int gEndPosHPZidx = 0;
int gMaxEndPosHPZ = 3;

bool gScoreKickstand = false;

bool gGoal2PZRH = false;

int gReady = 2;

////////////////////////////
//       Servo Positons   //
////////////////////////////

int const gkIrForward = 4; // Sensor Value for IR forward
int const gkGoalUp = 216; // Up value for GoalHook
int const gkGoalDown = 63; // Down value for GoalHook

////////////////////////////
// Utilities              //
////////////////////////////
char DispBool (bool iBool)
{
	if(iBool)
	{
		return 'T';
	}
	else
	{
		return 'F';
	}
}

////////////////////////////
// Button Task()          //
// Dynamic Menu for       //
// Autonomous             //
////////////////////////////
task ButtonTask()
{
	nSchedulePriority = kHighPriority;

	switch(nNxtButtonPressed)
	{
	case kLeftButton:
		if (gReady == 2)
		{
			gStartPosIdx--;

			if (gStartPosIdx < 0)
			{
				gStartPosIdx = gMaxStartPos;
			}

			nxtDisplayTextLine(2, gStartPos[gStartPosIdx]);
		}
		// Start Position
		else if (gReady == 3)
		{
			gStrategyIdx--;

			if (gStrategyIdx < 0)
			{
				gStrategyIdx = gMaxStrategy;
			}

			nxtDisplayTextLine(3, gStrategy[gStrategyIdx]);
		}
		// Idle Task
		else if (gReady == 4)
		{
			if(gStartPos[gStartPosIdx] == "Ramp")
			{
				if(gStrategy[gStrategyIdx] == "Offense")
				{
					gScoreIdx--;
					if (gScoreIdx < 0)
					{
						gScoreIdx = gMaxScoreO;
					}
					nxtDisplayTextLine(4,"Score:%s",gScore[gScoreIdx]);
				}
				else if(gStrategy[gStrategyIdx] == "Defense")
				{
					gBlockIdx--;
					if (gBlockIdx < 0)
					{
						gBlockIdx = gMaxBlock;
					}
					nxtDisplayTextLine(4,"Block:%s",gBlock[gBlockIdx]);
				}
				else if(gStrategy[gStrategyIdx] == "Hybrid")
				{
					gScoreIdx--;
					if (gScoreIdx < 0)
					{
						gScoreIdx = gMaxScoreH;
					}
					nxtDisplayTextLine(4,"Score:%s",gScore[gScoreIdx]);
				}
			}
			else if(gStartPos[gStartPosIdx] == "Parking Zone (PZ)")
			{
				if(gStrategy[gStrategyIdx] == "Offense")
				{
					gGoal2PZPZ = false;
					nxtDisplayTextLine(4,"Goal to PZ1:%c",DispBool(gGoal2PZPZ));
				}
				else if(gStrategy[gStrategyIdx] == "Hybrid")
				{
					gScoreHPZidx--;
					if (gScoreHPZidx < 0)
					{
						gScoreHPZidx = gMaxScoreHPZ;
					}
					nxtDisplayTextLine(4,"Score:%s",gScoreHPZ[gScoreHPZidx]);
				}
			}
		}
		else if (gReady == 5)
		{
			if (gStartPos[gStartPosIdx] == "Ramp")
			{
				if (gStrategy[gStrategyIdx] == "Offense")
				{
					gGoal2PZRO = false;
					nxtDisplayTextLine(5,"Goal to PZ:%c",DispBool(gGoal2PZRO));
				}
				else if(gStrategy[gStrategyIdx] == "Defense")
				{
					gSmallGoal = false;
					nxtDisplayTextLine(5,"Score Sm Goal:%c",DispBool(gSmallGoal));
				}
				else if(gStrategy[gStrategyIdx] == "Hybrid")
				{
					gBlockCenterGoal = false;
					nxtDisplayTextLine(5,"Score C Goal:%c",DispBool(gBlockCenterGoal));
				}
			}
			else if (gStartPos[gStartPosIdx] == "Parking Zone (PZ)")
			{
				if(gStrategy[gStrategyIdx] == "Hybrid")
				{
					gEndPosHPZidx--;
					if (gEndPosHPZidx < 0)
					{
						gEndPosHPZidx = gMaxEndPosHPZ;
					}
					nxtDisplayTextLine(5,"EndPos:%s",gEndPosHPZ[gEndPosHPZidx]);
				}
			}
		}
		else if (gReady == 6)
		{
			if(gStartPos[gStartPosIdx] == "Ramp")
			{
				if(gStrategy[gStrategyIdx] == "Offense")
				{
					gScoreKickstand = true;
					nxtDisplayTextLine(6,"Score Kickstand:%c",DispBool(gScoreKickstand));
				}
			}
		}
		break;

	case kRightButton:
		// Strategy (Offense, Defense)
		if (gReady == 2)
		{
			gStartPosIdx++;

			if (gStartPosIdx > gMaxStartPos)
			{
				gStartPosIdx = 0;
			}

			nxtDisplayTextLine(2, gStartPos[gStartPosIdx]);
		}
		// Start Position
		else if (gReady == 3)
		{
			gStrategyIdx++;

			if (gStrategyIdx > gMaxStrategy)
			{
				gStrategyIdx = 0;
			}

			nxtDisplayTextLine(3, gStrategy[gStrategyIdx]);
		}

		else if (gReady == 4)
		{
			if(gStartPos[gStartPosIdx] == "Ramp")
			{
				if(gStrategy[gStrategyIdx] == "Offense")
				{
					gScoreIdx++;
					if (gScoreIdx > gMaxScoreO)
					{
						gScoreIdx = 0;
					}
					nxtDisplayTextLine(4,"Score:%s",gScore[gScoreIdx]);
				}
				else if(gStrategy[gStrategyIdx] == "Defense")
				{
					gBlockIdx++;
					if (gBlockIdx > gMaxBlock)
					{
						gBlockIdx = 0;
					}
					nxtDisplayTextLine(4,"Block:%s",gBlock[gBlockIdx]);
				}
				else if(gStrategy[gStrategyIdx] == "Hybrid")
				{
					gScoreIdx++;
					if (gScoreIdx > gMaxScoreH)
					{
						gScoreIdx = 0;
					}
					nxtDisplayTextLine(4,"Score:%s",gScore[gScoreIdx]);
				}
			}
			else if(gStartPos[gStartPosIdx] == "Parking Zone (PZ)")
			{
				if(gStrategy[gStrategyIdx] == "Offense")
				{
					gGoal2PZPZ = true;
					nxtDisplayTextLine(4,"Goal to PZ3:%c",DispBool(gGoal2PZPZ));
				}
				else if(gStrategy[gStrategyIdx] == "Hybrid")
				{
					gScoreHPZidx++;
					if (gScoreHPZidx > gMaxScoreHPZ)
					{
						gScoreHPZidx = 0;
					}
					nxtDisplayTextLine(4,"Score:%s",gScoreHPZ[gScoreHPZidx]);
				}
			}
		}
		else if (gReady == 5)
		{
			if (gStartPos[gStartPosIdx] == "Ramp")
			{
				if (gStrategy[gStrategyIdx] == "Offense")
				{
					gGoal2PZRO = true;
					nxtDisplayTextLine(5,"Goal to PZ4:%c",DispBool(gGoal2PZRO));
				}
				else if(gStrategy[gStrategyIdx] == "Defense")
				{
					gSmallGoal = true;
					nxtDisplayTextLine(5,"Score Sm Goal:%c",DispBool(gSmallGoal));
				}
				else if(gStrategy[gStrategyIdx] == "Hybrid")
				{
					gBlockCenterGoal = true;
					nxtDisplayTextLine(5,"Score Sm Goal:%c",DispBool(gBlockCenterGoal));
				}
			}
			else if (gStartPos[gStartPosIdx] == "Parking Zone (PZ)")
			{
				if(gStrategy[gStrategyIdx] == "Hybrid")
				{
					gEndPosHPZidx++;
					if (gEndPosHPZidx > gMaxEndPosHPZ)
					{
						gEndPosHPZidx = 0;
					}
					nxtDisplayTextLine(5,"EndPos:%s",gEndPosHPZ[gEndPosHPZidx]);
				}
			}
		}
		else if (gReady == 6)
		{
			if(gStartPos[gStartPosIdx] == "Ramp")
			{
				if(gStrategy[gStrategyIdx] == "Offense")
				{
					gScoreKickstand = true;
					nxtDisplayTextLine(6,"Score Kickstand:%c",DispBool(gScoreKickstand));
				}
			}
		}

		break;
	case kEnterButton:
		gReady++;

		if (gReady == 3)
		{
			nxtDisplayTextLine(3, gStrategy[gStrategyIdx]);
		}
		else if (gReady == 4)
		{
			if(gStartPos[gStartPosIdx] == "Ramp")
			{
				if(gStrategy[gStrategyIdx] == "Offense" || gStrategy[gStrategyIdx] == "Hybrid")
				{
					nxtDisplayTextLine(4,"Score:%s", gScore[gScoreIdx]);
				}
				else if(gStrategy[gStrategyIdx] == "Defense")
				{
					nxtDisplayTextLine(4,"Block:%s", gBlock[gBlockIdx]);
				}
			}
			else if (gStartPos[gStartPosIdx] == "Parking Zone (PZ)")
			{
				if(gStrategy[gStrategyIdx] == "Offense")
				{
					nxtDisplayTextLine(4,"Goal to PZ8:%c",DispBool(gGoal2PZPZ));
				}
				else if(gStrategy[gStrategyIdx] == "Hybrid")
				{
					nxtDisplayTextLine(4,"Score:%s",gScoreHPZ[gScoreHPZidx]);
				}
			}
		}
		else if (gReady == 5)
		{
			if (gStartPos[gStartPosIdx] == "Ramp")
			{
				if (gStrategy[gStrategyIdx] == "Offense")
				{
					nxtDisplayTextLine(5,"Goal to PZ9:%c",DispBool(gGoal2PZRO));
				}
				else if (gStrategy[gStrategyIdx] == "Defense")
				{
					nxtDisplayTextLine(5,"Score Sm Goal:%c",DispBool(gSmallGoal));
				}
				else if (gStrategy[gStrategyIdx] == "Hybrid")
				{
					nxtDisplayTextLine(5,"Block C Goal:%c",DispBool(gBlockCenterGoal));
				}
			}
			else if (gStartPos[gStartPosIdx] == "Parking Zone (PZ)")
			{
				if (gStrategy[gStrategyIdx] == "Offense")
				{
					nxtDisplayCenteredTextLine(7,"Ready!!!");
				}
				else if (gStrategy[gStrategyIdx] == "Defense")
				{
					nxtDisplayCenteredTextLine(7,"Ready!!!");
				}
				else if (gStrategy[gStrategyIdx] == "Hybrid")
				{
					nxtDisplayTextLine(5,"EndPos:%s",gEndPosHPZ[gEndPosHPZidx]);
				}
			}
		}
		else if (gReady == 6)
		{
			if (gStartPos[gStartPosIdx] == "Ramp")
			{
				if (gStrategy[gStrategyIdx] == "Offense")
				{
					nxtDisplayTextLine(6,"Score KickStand:%c",DispBool(gScoreKickstand));
				}
				else if (gStrategy[gStrategyIdx] == "Defense")
				{
					nxtDisplayCenteredTextLine(7,"Ready!!!");
				}
				else if (gStrategy[gStrategyIdx] == "Hybrid")
				{
					nxtDisplayCenteredTextLine(7,"Ready!!!");
				}
			}
			else if (gStartPos[gStartPosIdx] == "Parking Zone (PZ)")
			{
				if (gStrategy[gStrategyIdx] == "Offense")
				{
					nxtDisplayCenteredTextLine(7,"Ready!!!");
				}
				else if (gStrategy[gStrategyIdx] == "Defense")
				{
					nxtDisplayCenteredTextLine(7,"Ready!!!");
				}
				else if (gStrategy[gStrategyIdx] == "Hybrid")
				{
					nxtDisplayCenteredTextLine(7,"Ready!!!");
				}
			}
		}
		else if (gReady == 7)
		{
			nxtDisplayCenteredTextLine(7,"Ready!!!");
		}

		break;
	case kExitButton:
		gReady--;

		if (gReady < 2)
		{
			gReady = 2;
		}

		else if (gReady == 6)
		{
			nxtDisplayClearTextLine(7);
		}

		else
		{
			nxtDisplayClearTextLine(gReady+1);
		}
		break;
	}

	return;
}

////////////////////////////////////////////////////////////////////
//                                                                //
//                                                                //
//                        Movement                                //
//Needs Power, Distance (in.), and Direction (Forwards/Backwards) //
//                                                                //
//                                                                //
////////////////////////////////////////////////////////////////////

void drive(int iDistance,Movedir iDir = FORWARD, int iPower = 100, IncrementSize iIncrement = INCHES, bool iWait = true, bool Am2694 = false){
	int vOffset = 1; // Forwards or Backwards

	int tpi = 123; // How many ticks per inch
	int AM2694tpi = 100; // How many ticks per inch in AM-2694 NeveRest 40 Motors

	int leftMotorPower = iPower; // Power in Left Motor
	int rightMotorPower = iPower; // Power in Right Motor

	int syncInterval = 250; // How many milliseconds does it take to do the check
	int syncError = 50;  // How many ticks the motors can be off

	int gSlowThresh = 0; // 100
	unsigned long syncTime = syncInterval + nPgmTime;

	if (iDir == BACKWARD)
	{
		vOffset = 1;
	}
	int inchdist;
	if (Am2694 == true)
	{
		inchdist = AM2694tpi * iDistance;
	}
	else
	{
		inchdist = tpi * iDistance; // How many ticks in the given distance
	}

	if (iIncrement == FEET)
	{
		inchdist= inchdist * 12;
	}
	else if (iIncrement == INCHES)
	{
		inchdist = inchdist;
	}

	nMotorEncoder[DriveLeft] = 0; // Reset Motor Encoder. Could have been either Left or Right motor

	motor[DriveLeft] = iPower * vOffset; // Motor Power
	motor[DriveRight] = iPower * vOffset; // Motor Power

	while (abs(nMotorEncoder[DriveLeft]) < inchdist - gSlowThresh)
	{
		if (nPgmTime >= syncTime)
		{
			if (abs(nMotorEncoder[DriveLeft]) > abs(nMotorEncoder[DriveRight] + syncError))
				// ^If left motor power is greater than the right motor power
			{
				if (iPower < leftMotorPower) // check if motor has already had a motor increment (default) or decrement
				{
					leftMotorPower--; // Decrement Motor Power. In other words: Left loses power
				}
				else
				{
					rightMotorPower++; // Increment Motor Power. In other words: Right gains power
				}
			}
			else if (abs(nMotorEncoder[DriveLeft]) + syncError < abs(nMotorEncoder[DriveRight]))
				// ^If right motor power is greater than left motor power
			{
				if (iPower < rightMotorPower) // check if motor has already had a motor increment (default)or decrement
				{
					rightMotorPower--; // Decrement Right Motor Power
				}
				else
				{
					leftMotorPower++; // Increment Left Motor Power
				}
			}
			motor[DriveLeft] = leftMotorPower * vOffset; // Reassign values into motor power
			motor[DriveRight] = rightMotorPower * vOffset; // Reassign values into motor power
			syncTime = syncInterval + nPgmTime; // Define new check time
		}
	}
	while (abs(nMotorEncoder[DriveLeft]) < inchdist)
	{
		motor[DriveLeft] = 10;
		motor[DriveRight] = 10;
	}
	// stop.

	motor[DriveLeft] = 0;
	motor[DriveRight] = 0;
	if(iWait)
	{
		wait10Msec(30);
	}
}
////////////////////////////////////////////////////////////////////
//                                                                //
//                                                                //
//                        Spin Turn                               //
//   Needs Power, Degrees, and Direction (Left/Right)             //
//                                                                //
//                                                                //
////////////////////////////////////////////////////////////////////

void turn (Turndir iDir, float iDegrees = 90, int iPower = 50)
{
	float gDegreeMultiplier = 1.05;
	float vcurrposition = 0;
	int   vprevtime     = nPgmTime;
	int   vcurrtime;
	float vcurrRate;
	int   vOffset;
	float deltaSecs;
	float degChange;

	if (iDir == LEFT)
	{
		motor[DriveLeft] = iPower * -1;
		motor[DriveRight] = iPower;
		vOffset = -1;
	}
	else
	{
		motor[DriveLeft] = iPower;
		motor[DriveRight] = iPower * -1;
		vOffset = 1;
	}
	vprevtime= nPgmTime;
	while (vcurrposition < iDegrees * gDegreeMultiplier)
	{
		vcurrRate = HTGYROreadRot(gyro) * vOffset;
		vcurrtime = nPgmTime;
		deltaSecs = (vcurrtime - vprevtime) / 1000.00;
		if (deltaSecs < 0)
		{
			deltaSecs = ((float)(vcurrtime + 1024) - (vprevtime + 1024) / 1000.00);
		}
		degChange = vcurrRate * deltaSecs;
		vcurrposition = vcurrposition + degChange;
		vprevtime = vcurrtime;
	}
	motor[DriveLeft] = 0;
	motor[DriveRight] = 0;
}

/////////////////////////////////////////////////////////////
//                                                         //
//Initialize Robot                                         //
//                                                         //
/////////////////////////////////////////////////////////////
void initializeRobot()
{
	HTGYROstartCal(gyro);
	disableDiagnosticsDisplay();
	eraseDisplay();
	nNxtButtonTask = ButtonTask;  //Starts up the button task defined above for selecting the auto routine
	nNxtExitClicks = 2; //Normally the gray NXT button exits the program, but since we use the exit button
	nxtDisplayCenteredTextLine(1, "Autonomous 7208");
	nxtDisplayTextLine(2, gStartPos[gStartPosIdx]);
}
/////////////////////////////////////////////////////////////
//                                                         //
//Strategies                                               //
//                                                         //
/////////////////////////////////////////////////////////////
void OffenseRamp()
{
	drive(7*12); // Drive Forward Until Off The Ramp
	if (gScore[gScoreIdx] == "Small Goal" || gGoal2PZRO)
	{
		drive(1*12); // Drive up to Small Goal
		if (gScore[gScoreIdx] == "Small Goal")
		{
			// Turn Around
			turn(LEFT,180);
			// Score in Small Goal
		}
		if (gGoal2PZRO && gScore[gScoreIdx] != "Small Goal")
		{
			servo[GoalHook] = gkGoalDown; //latch on to goal
		}
		else
		{
			turn(LEFT,180);
			servo[GoalHook] = gkGoalDown;
		}
	}

	drive(2*12);
	turn(LEFT);
	if(SensorValue[irBeacon] == gkIrForward)
	{
	}
	else if(SensorValue[irBeacon] != 0) // IR Sensor is Skewed
	{
	}
	else // Can't Find IR Sensor
	{
	}

	if(gScoreKickstand)
	{
		// Use ir values to find kickstand and goal
		// Knock down kickstand
		if(gScore[gScoreIdx] != "Center Goal")
		{
			// Go to Parking Zone
		}
		else
		{
			// Go to Center Goal
			// Then to parking zone
		}
	}
	if (gGoal2PZRO && gScoreKickstand == false && gScore[gScoreIdx] == "Small Goal")
	{
		// Go to PZ
	}
}

void DefenseRamp()
{
	// Drive off Ramp
	if (gSmallGoal)
	{
		// Drive forward and score in goal
		// Go back to the corner
	}
	// Turn Right
	// Drive and read IR sensor
	// Drive to Center Goal
	if (gBlock[gBlockIdx] == "Kickstand")
	{
		// Stop at kickstand
	}
}

void HybridRamp()
{
	// Drive off ramp
	if (gScore[gScoreIdx] == "Small Goal")
	{
		// Drive forward and score in goal
		// Drive backward and stop
	}
	// Drive forward and sense IR beacon
	if (gBlockCenterGoal)
	{
	}
	else
	{
		if (gScore[gScoreIdx] == "Center Goal")
		{
			// go around kickstand and score in center goal
			if (gBlockCenterGoal)
			{
				// go back to the center goal
			}
		}
	}
}

void OffenseParkingZone()
{
	// Score on Center Goal
	// Score on Kickstand
	if (gGoal2PZPZ)
	{
		// get small goal and bring it to parking zone
	}
}

void DefenseParkingZone()
{
	// move in front of opponent's ramp
}

void HybridParkingZone()
{
	// Forward
  // Sense Ir
  // If (BlockCenterGoal and ScoreNothing) STOP!

  // If (BlockKickstand and ScoreNothing) Go to Kickstand and STOP

  // If (ScoreKickstand or ScoreBoth) Go Hit Kickstand
    // If (ScoreBoth) Go and score in Center Goal
    // Else If (BlockKickstand) go and stop next to kickstand
    // Else If (BlockCenterGoal) go and stop next to center
  // Else If (ScoreCenterGoal) Go around kickstand and score in Center Goal
}

task main()
{
	initializeRobot();
	waitForStart();

	if(gStartPos[gStartPosIdx] == "Ramp")
	{
		if (gStrategy[gStrategyIdx] == "Offense")
		{
			OffenseRamp();
		}
		else if (gStrategy[gStrategyIdx] == "Defense")
		{
			DefenseRamp();
		}
		else if (gStrategy[gStrategyIdx] == "Hybrid")
		{
			HybridRamp();
		}
	}
	else if(gStartPos[gStartPosIdx] == "Parking Zone (PZ)")
	{
		if (gStrategy[gStrategyIdx] == "Offense")
		{
			OffenseParkingZone();
		}
		else if (gStrategy[gStrategyIdx] == "Defense")
		{
			DefenseParkingZone();
		}
		else if (gStrategy[gStrategyIdx] == "Hybrid")
		{
			HybridParkingZone();
		}
	}
}
