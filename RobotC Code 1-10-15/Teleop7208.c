#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  HTServo)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     gyro,           sensorI2CHiTechnicGyro)
#pragma config(Sensor, S4,     irBeacon,       sensorHiTechnicIRSeeker1200)
#pragma config(Motor,  mtr_S1_C1_1,     DriveLeft,     tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     DriveRight,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     ArmRot,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     ArmLift,        tmotorTetrix, openLoop, reversed)
#pragma config(Servo,  srvo_S1_C3_1,    GoalHook,             tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    TrapDoor,        tServoStandard)
#pragma config(Servo,  srvo_S1_C3_3,    SweepRotLeft,         tServoStandard)
#pragma config(Servo,  srvo_S1_C3_4,    Sweeper,              tServoContinuousRotation) // Need to Check
#pragma config(Servo,  srvo_S1_C3_5,    ScoopRotRight,        tServoStandard)
#pragma config(Servo,  srvo_S1_C3_6,    ScoopRotLeft,         tServoStandard)
#pragma config(Servo,  srvo_S1_C4_1,    SweepRotRight,             tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    servo8,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_3,    servo9,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_4,    servo10,              tServoNone)
#pragma config(Servo,  srvo_S1_C4_5,    servo11,              tServoNone)
#pragma config(Servo,  srvo_S1_C4_6,    servo12,              tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

////////////////////////////////////////////
//                                        //
//                                        //
//  Tele-Op                               //
//  Use at competition                    //
//  Use with 2 controllers.               //
//                                        //
//                                        //
////////////////////////////////////////////

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.

typedef enum {Waiting,GoingUp,GoingDown}LiftArmStateType;
typedef enum {Waiting,GoingForward,GoingBackward}RotArmStateType;

int const gkSafeLiftSpeedUp   = 75;
int const gkSafeLiftSpeedDown = -50;
int const gkSafeRotSpeedUp    = 35;
int const gkSafeRotSpeedDown  = 100;
int const gkRotationTurnoverForward = -1672;
int const gkRotationTurnoverBackward = -1336;

bool gGoalGrabUp = true;
bool gGoalGrabBtnUp = true;
int const gkGoalUp = 216; // Up value for GoalHook
int const gkGoalDown = 63; // Down value for GoalHook

bool gSweepUp = true;
bool gSweepBtnUp = true;
int const gkSweepLeftUp    = 128; // Up value for GoalHook
int const gkSweepLeftDown  = 128; // Down value for GoalHook
int const gkSweepRightUp   = 128; // Up value for GoalHook
int const gkSweepRightDown = 128; // Down value for GoalHook

int gScoopServoLeftPos = 128;  // Servo Position
int gScoopServoRightPos = 128;

int const gkTrapDoorUp  = 128;
int const gkTrapDoorDown = 1;

LiftArmStateType gLiftArmState = Waiting;
RotArmStateType gRotArmState   = Waiting;
int gDestLiftArm = 0;
int gDestRotArm  = 0;
int const gkBaseDestRot        = 0;
int const gkBaseDestLift       = 0;
int const gkSmallGoalDestRot   = -2100;
int const gkSmallGoalDestLift  = 0;
int const gkMediumGoalDestRot  = -1675;
int const gkMediumGoalDestLift = 0;
int const gkHighGoalDestRot    = 0;
int const gkHighGoalDestLift   = 0;
int const gkCenterGoalDestRot  = 0;
int const gkCenterGoalDestLift = 0;

void initializeRobot()
{
	disableDiagnosticsDisplay();
	eraseDisplay();
	nxtDisplayTextLine(1,"Teleop 7208");
	nMotorEncoder[ArmLift] = gkBaseDestLift;
	nMotorEncoder[ArmRot]  = gkBaseDestRot;
	servo[GoalHook]        = gkGoalUp;
	servo[SweepRotLeft]    = gkSweepLeftUp;
	servo[SweepRotRight]   = gkSweepRightUp;
	servo[Sweeper]         = 127;

  gScoopServoLeftPos  = 128;  // Servo Position
  gScoopServoRightPos = 128;

	servo[ScoopRotLeft]  = gScoopServoLeftPos;
	servo[ScoopRotRight] = gScoopServoRightPos;
	servo[TrapDoor]      = gkTrapDoorUp;

  gGoalGrabUp = true;
  gGoalGrabBtnUp = true;
  gSweepUp = true;
  gSweepBtnUp = true;

  gLiftArmState  = Waiting;
  gRotArmState   = Waiting;
}
char DispBool (bool iBool)
{
	if (iBool)
	{
		return 'T';
	}
	else
	{
		return 'F';
	}
}
////////////////////////////////////////////////////////////////////
//                                                                //
//                                                                //
//                        Drive Routine Controls                  //
//                        Notes:                                  //
//                        - adjustMotorControl() is used for      //
//                          calibrating the drive() function      //
//                        - drive is the actual joystick command  //
//                                                                //
//                                                                //
////////////////////////////////////////////////////////////////////

// Adjust joystick controls
int joyMotorAdjust(int iJoystickReading, int iPowerMax, int iThreshHold){
	int vMotorPower = iJoystickReading;
	if (abs(vMotorPower) < iThreshHold) {
		vMotorPower = 0;
	}

	else
	{
		if (vMotorPower< 0)
		{
			vMotorPower= vMotorPower+ iThreshHold;
		}
		else
		{
			vMotorPower= vMotorPower-iThreshHold;
		}
		vMotorPower= floor((vMotorPower*iPowerMax) / (127-iThreshHold));
	}
	return vMotorPower;
}

// Drive function
void joyDrive()
{
	int maxPower = 80;
	if (joy1Btn(6)) // Slow Down
	{
		maxPower = 25;
	}
	else if (joy1Btn(8)) // Speed Up
	{
		maxPower = 100;
	}
	else // Normal Drive
	{
		maxPower = 80;
	}
	motor[DriveLeft]  = joyMotorAdjust(joystick.joy1_y2 * -1, maxPower,30); // Go through adjustMotorControl()
	motor[DriveRight] = joyMotorAdjust(joystick.joy1_y1 * -1, maxPower, 30); // Go through adjustMotorControl()
}

void joyGoalGrab()
{
	if (joy1Btn(1))
	{
		if (gGoalGrabBtnUp)
		{
			gGoalGrabBtnUp = false;
			if (gGoalGrabUp)
			{
				servo[GoalHook] = gkGoalDown;
				gGoalGrabUp = false;
			}
			else
			{
				servo[GoalHook] = gkGoalUp;
				gGoalGrabUp = true;
			}
		}
	}
	else
	{
		gGoalGrabBtnUp = true;
	}
}
void joySweeper()
{
	if (joy1Btn(2))
	{
		if (gSweepBtnUp)
		{
			gSweepBtnUp = false;
			if (gSweepUp)
			{
				servo[SweepRotLeft] = gkSweepLeftDown;
				servo[SweepRotRight] = gkSweepRightDown;
				gSweepUp = false;
			}
			else
			{
				servo[SweepRotLeft] = gkSweepLeftUp;
				servo[SweepRotRight] = gkSweepRightUp;
				gSweepUp = true;
			}
		}
	}
	else
	{
		gSweepBtnUp = true;
	}

	if(joy1Btn(3))
	{
		servo[Sweeper] = 255;
	}
	else
	{
		servo[Sweeper] = 127;
	}
}

void joyScoop()
{
	if(joy2Btn(5)) // Scoop Up
	{
		if (gScoopServoLeftPos < 255)
		{
			servo[ScoopRotLeft]  = ++gScoopServoLeftPos;
			servo[ScoopRotRight] = --gScoopServoRightPos;
		}
	}
	else if (joy2Btn(7)) // Scoop Down
	{
		if (gScoopServoLeftPos > 0)
		{
			servo[ScoopRotLeft]  = --gScoopServoLeftPos;
			servo[ScoopRotRight] = ++gScoopServoRightPos;
		}
	}
}

void joyTrapDoor()
{
	if(joy2Btn(6)) // Trap Door Up
	{
		servo[TrapDoor] = gkTrapDoorUp;
	}
	else if (joy2Btn(8)) // Trap Door Down
	{
		servo[TrapDoor] = gkTrapDoorDown;
	}
}

void setArmState() // TheUglyPart()'s spawn!
{
	if (nMotorEncoder[ArmLift] < gDestLiftArm) // Arm goes up
	{
		gLiftArmState = GoingUp;
	}
	else if (nMotorEncoder[ArmLift] > gDestLiftArm) // Arm goes down
	{
		gLiftArmState = GoingDown;
	}

	if (nMotorEncoder[ArmRot] < gDestRotArm) // Rotation of Arm Forward
	{
		gRotArmState = GoingForward;
	}
	else if (nMotorEncoder[ArmRot] > gDestRotArm) // Rotation of Arm Backward
	{
		gRotArmState = GoingBackward;
	}
}
void joyArm() // AKA TheUglyPart()!
{
	if(joy2Btn(1))
	{
		if(nMotorEncoder[ArmRot] >= gkRotationTurnoverForward)
		{
			motor[ArmRot] = gkSafeRotSpeedDown * -1;
		}
		else
		{
			motor[ArmRot] = gkSafeRotSpeedUp * -1;
		}
		gRotArmState  = Waiting;
		gLiftArmState = Waiting;
	}
	else if (joy2Btn(2))
	{
		motor[ArmLift] = gkSafeLiftSpeedDown;
		gLiftArmState = Waiting;
		gRotArmState  = Waiting;
	}
	else if (joy2Btn(3))
	{
		if(nMotorEncoder[ArmRot] <= gkRotationTurnoverBackward)
		{
			motor[ArmRot] = gkSafeRotSpeedDown;
		}
		else
		{
			motor[ArmRot] = gkSafeRotSpeedUp;
		}
		gRotArmState  = Waiting;
		gLiftArmState = Waiting;
	}
	else if (joy2Btn(4))
	{
		motor[ArmLift] = gkSafeLiftSpeedUp;
		gLiftArmState = Waiting;
		gRotArmState  = Waiting;
	}
	else
	{
		if(joy2Btn(9)) // Base Position (ground)
		{
			gDestLiftArm = gkBaseDestLift;
			gDestRotArm  = gkBaseDestRot;
			setArmState();
		}
		else if (joystick.joy2_TopHat == 4) // Small Goal (30cm)
		{
			gDestLiftArm = gkSmallGoalDestLift;
			gDestRotArm  = gkSmallGoalDestRot;
			setArmState();
		}
		else if (joystick.joy2_TopHat == 6) // Medium Goal(60cm)
		{
			gDestLiftArm = gkMediumGoalDestLift;
			gDestRotArm  = gkMediumGoalDestRot;
			setArmState();
		}
		else if (joystick.joy2_TopHat == 2) // High Goal (90cm)
		{
			gDestLiftArm = gkHighGoalDestLift;
			gDestRotArm  = gkHighGoalDestRot;
			setArmState();
		}
		else if (joystick.joy2_TopHat == 0) // Center Goal (120cm)
		{
			gDestLiftArm = gkCenterGoalDestLift;
			gDestRotArm  = gkCenterGoalDestRot;
			setArmState();
		}

		if (nMotorEncoder[ArmLift] < gDestLiftArm && gLiftArmState == GoingUp) // Arm goes up
		{
			motor[ArmLift] = gkSafeLiftSpeedUp;
		}
		else if (nMotorEncoder[ArmLift] > gDestLiftArm && gLiftArmState == GoingDown) // Arm goes down
		{
			motor[ArmLift] = gkSafeLiftSpeedDown;
		}
		else // Stop
		{
			motor[ArmLift] = 0;
			gLiftArmState = Waiting;
		}

		if (nMotorEncoder[ArmRot] < gDestRotArm && gRotArmState == GoingForward && nMotorEncoder[ArmRot] <= gkRotationTurnoverBackward) // Rotation of Arm up
		{
			motor[ArmRot] = gkSafeRotSpeedDown;
		}
		else if (nMotorEncoder[ArmRot] < gDestRotArm && gRotArmState == GoingForward && nMotorEncoder[ArmRot] > gkRotationTurnoverBackward) // Rotation of Arm up
		{
			motor[ArmRot] = gkSafeRotSpeedUp;
		}
		else if (nMotorEncoder[ArmRot] > gDestRotArm && gRotArmState == GoingBackward && nMotorEncoder[ArmRot] >= gkRotationTurnoverForward) // Rotation of Arm Down
		{
			motor[ArmRot] = gkSafeRotSpeedDown * -1;
		}
		else if (nMotorEncoder[ArmRot] > gDestRotArm && gRotArmState == GoingBackward && nMotorEncoder[ArmRot] < gkRotationTurnoverForward) // Rotation of Arm Down
		{
			motor[ArmRot] = gkSafeRotSpeedUp * -1;
		}
		else // Stop
		{
			motor[ArmRot] = 0;
			gRotArmState = Waiting;
		}
	}
}
task main()
{
	initializeRobot(); // Pre-defined servo start positons
	waitForStart();   // wait for start of tele-op phase

	while (true)
	{
		getJoystickSettings(joystick);

		// Controller 1 //
		joyDrive();
		joyGoalGrab();
		joySweeper();

		// Controller 2 //
		joyScoop();
		joyTrapDoor();
		joyArm();

		nxtDisplayTextLine(2,"Lift: %i",nMotorEncoder[ArmLift]); // Debugger Values
		nxtDisplayTextLine(3,"Rot: %i",nMotorEncoder[ArmRot]);   // Debugger Values
	}
}
